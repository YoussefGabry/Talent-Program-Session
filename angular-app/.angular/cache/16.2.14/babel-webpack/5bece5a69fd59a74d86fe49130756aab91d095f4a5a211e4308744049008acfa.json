{"ast":null,"code":"import _asyncToGenerator from \"D:/Verina/SPA session/angular-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { BrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\nfunction enableProdMode() {\n  try {\n    // The `enableProdMode` will throw an error if it's called multiple times,\n    // but it may be called multiple times when dependencies are shared.\n    i0.enableProdMode();\n  } catch {\n    // Nothing to do here.\n  }\n}\nclass SingleSpaPlatformLocation extends BrowserPlatformLocation {\n  constructor() {\n    super(...arguments);\n    // This is a simple marker that helps us to ignore PopStateEvents\n    // that was not dispatched by the browser.\n    this.skipNextPopState = false;\n    this.source = 'Window.addEventListener:popstate';\n  }\n  pushState(state, title, url) {\n    this.skipNextPopState = true;\n    super.pushState(state, title, url);\n  }\n  replaceState(state, title, url) {\n    this.skipNextPopState = true;\n    super.replaceState(state, title, url);\n  }\n  onPopState(fn) {\n    // `Zone.current` will reference the zone that serves as an execution context\n    // to some specific application, especially when `onPopState` is called.\n    const zone = Zone.current;\n    // Wrap any event listener into zone that is specific to some application.\n    // The main issue is `back/forward` buttons of browsers, because they invoke\n    // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n    // overrides `history.replaceState` Angular's zone cannot intercept this event.\n    // Only the root zone is able to intercept all events.\n    // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n    fn = zone.wrap(fn, this.source);\n    const onPopStateListener = event => {\n      // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n      // by `single-spa` starting from `5.4` version. We need this check because we want\n      // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n      const popStateEventWasDispatchedBySingleSpa = !!event.singleSpa;\n      if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n        this.skipNextPopState = false;\n      } else {\n        fn(event);\n      }\n    };\n    return super.onPopState(onPopStateListener);\n  }\n  /** @nocollapse */\n  static #_ = this.ɵfac = /* @__PURE__ */function () {\n    let ɵSingleSpaPlatformLocation_BaseFactory;\n    return function SingleSpaPlatformLocation_Factory(t) {\n      return (ɵSingleSpaPlatformLocation_BaseFactory || (ɵSingleSpaPlatformLocation_BaseFactory = i0.ɵɵgetInheritedFactory(SingleSpaPlatformLocation)))(t || SingleSpaPlatformLocation);\n    };\n  }();\n  /** @nocollapse */\n  static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SingleSpaPlatformLocation,\n    factory: SingleSpaPlatformLocation.ɵfac\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SingleSpaPlatformLocation, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\nfunction getSingleSpaExtraProviders() {\n  return [{\n    provide: SingleSpaPlatformLocation,\n    deps: [[new Inject(DOCUMENT)]]\n  }, {\n    provide: PlatformLocation,\n    useExisting: SingleSpaPlatformLocation\n  }];\n}\nconst defaultOptions = {\n  // Required options that will be set by the library consumer.\n  NgZone: null,\n  bootstrapFunction: null,\n  template: null,\n  // Optional options\n  Router: undefined,\n  domElementGetter: undefined,\n  updateFunction: () => Promise.resolve(),\n  bootstrappedNgModuleRefOrAppRef: null\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nfunction singleSpaAngular(userOptions) {\n  if (NG_DEV_MODE && typeof userOptions !== 'object') {\n    throw Error('single-spa-angular requires a configuration object');\n  }\n  const options = {\n    ...defaultOptions,\n    ...userOptions\n  };\n  if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n    throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n  }\n  if (NG_DEV_MODE && typeof options.template !== 'string') {\n    throw Error('single-spa-angular must be passed options.template string');\n  }\n  if (NG_DEV_MODE && !options.NgZone) {\n    throw Error(`single-spa-angular must be passed the NgZone option`);\n  }\n  if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n    // We call `console.warn` except of throwing `new Error()` since this will not\n    // be a breaking change.\n    console.warn(`single-spa-angular must be passed the NavigationStart option`);\n  }\n  return {\n    bootstrap: bootstrap.bind(null, options),\n    mount: mount.bind(null, options),\n    unmount: unmount.bind(null, options),\n    update: options.updateFunction\n  };\n}\nfunction bootstrap(_x) {\n  return _bootstrap.apply(this, arguments);\n}\nfunction _bootstrap() {\n  _bootstrap = _asyncToGenerator(function* (options) {\n    // Angular provides an opportunity to develop `zone-less` application, where developers\n    // have to trigger change detection manually.\n    // See https://angular.io/guide/zone#noopzone\n    if (options.NgZone === 'noop') {\n      return;\n    }\n    // Note that we have to make it a noop function because it's a static property and not\n    // an instance property. We're unable to configure it for multiple apps when dependencies\n    // are shared and reference the same `NgZone` class. We can't determine where this function\n    // is being executed or under which application, making it difficult to assert whether this\n    // app is running under its zone.\n    options.NgZone.assertInAngularZone = () => {};\n    options.NgZone.assertNotInAngularZone = () => {};\n    options.routingEventListener = () => {\n      options.bootstrappedNgZone.run(() => {\n        // See https://github.com/single-spa/single-spa-angular/issues/86\n        // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n        // unless we tell Zone that something happened\n      });\n    };\n  });\n  return _bootstrap.apply(this, arguments);\n}\nfunction mount(_x2, _x3) {\n  return _mount.apply(this, arguments);\n}\nfunction _mount() {\n  _mount = _asyncToGenerator(function* (options, props) {\n    getContainerElementAndSetTemplate(options, props);\n    const bootstrapPromise = options.bootstrapFunction(props);\n    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n      throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n    }\n    const ngModuleRefOrAppRef = yield bootstrapPromise;\n    if (NG_DEV_MODE) {\n      if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {\n        throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n      }\n    }\n    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);\n    const ngZoneEnabled = options.NgZone !== 'noop';\n    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n      throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n    }\n    const bootstrappedOptions = options;\n    if (ngZoneEnabled) {\n      const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);\n      // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n      // function was not called.\n      if (singleSpaPlatformLocation !== null) {\n        skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);\n      }\n      bootstrappedOptions.bootstrappedNgZone = ngZone;\n      window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n    }\n    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;\n    return ngModuleRefOrAppRef;\n  });\n  return _mount.apply(this, arguments);\n}\nfunction unmount(options) {\n  return Promise.resolve().then(() => {\n    if (options.routingEventListener) {\n      window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n    }\n    options.bootstrappedNgModuleRefOrAppRef.destroy();\n    options.bootstrappedNgModuleRefOrAppRef = null;\n  });\n}\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {\n  if (!options.NavigationStart) {\n    // As discussed we don't do anything right now if the developer doesn't provide\n    // `options.NavigationStart` since this might be a breaking change.\n    return;\n  }\n  const router = ngModuleRefOrAppRef.injector.get(options.Router);\n  const subscription = router.events.subscribe(event => {\n    if (event instanceof options.NavigationStart) {\n      const currentNavigation = router.getCurrentNavigation();\n      // This listener will be set up for each Angular application\n      // that has routing capabilities.\n      // We set `skipLocationChange` for each non-imperative navigation,\n      // Angular router checks under the hood if it has to change\n      // the browser URL or not.\n      // If `skipLocationChange` is truthy then Angular router will not call\n      // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n      if (currentNavigation.trigger !== 'imperative') {\n        currentNavigation.extras.skipLocationChange = true;\n        currentNavigation.extras.replaceUrl = false;\n      }\n    }\n  });\n  ngModuleRefOrAppRef.onDestroy(() => subscription.unsubscribe());\n}\n\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular };","map":{"version":3,"names":["i0","Injectable","Inject","getContainerElementAndSetTemplate","BrowserPlatformLocation","DOCUMENT","PlatformLocation","enableProdMode","SingleSpaPlatformLocation","constructor","arguments","skipNextPopState","source","pushState","state","title","url","replaceState","onPopState","fn","zone","Zone","current","wrap","onPopStateListener","event","popStateEventWasDispatchedBySingleSpa","singleSpa","_","ɵfac","ɵSingleSpaPlatformLocation_BaseFactory","SingleSpaPlatformLocation_Factory","t","ɵɵgetInheritedFactory","_2","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","getSingleSpaExtraProviders","provide","deps","useExisting","defaultOptions","NgZone","bootstrapFunction","template","Router","undefined","domElementGetter","updateFunction","Promise","resolve","bootstrappedNgModuleRefOrAppRef","NG_DEV_MODE","singleSpaAngular","userOptions","Error","options","NavigationStart","console","warn","bootstrap","bind","mount","unmount","update","_x","_bootstrap","apply","_asyncToGenerator","assertInAngularZone","assertNotInAngularZone","routingEventListener","bootstrappedNgZone","run","_x2","_x3","_mount","props","bootstrapPromise","ngModuleRefOrAppRef","destroy","singleSpaPlatformLocation","injector","get","ngZoneEnabled","bootstrappedOptions","ngZone","skipLocationChangeOnNonImperativeRoutingTriggers","window","addEventListener","then","removeEventListener","router","subscription","events","subscribe","currentNavigation","getCurrentNavigation","trigger","extras","skipLocationChange","replaceUrl","onDestroy","unsubscribe"],"sources":["D:/Verina/SPA session/angular-app/node_modules/single-spa-angular/fesm2022/single-spa-angular.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { BrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\n\nfunction enableProdMode() {\n    try {\n        // The `enableProdMode` will throw an error if it's called multiple times,\n        // but it may be called multiple times when dependencies are shared.\n        i0.enableProdMode();\n    }\n    catch {\n        // Nothing to do here.\n    }\n}\n\nclass SingleSpaPlatformLocation extends BrowserPlatformLocation {\n    constructor() {\n        super(...arguments);\n        // This is a simple marker that helps us to ignore PopStateEvents\n        // that was not dispatched by the browser.\n        this.skipNextPopState = false;\n        this.source = 'Window.addEventListener:popstate';\n    }\n    pushState(state, title, url) {\n        this.skipNextPopState = true;\n        super.pushState(state, title, url);\n    }\n    replaceState(state, title, url) {\n        this.skipNextPopState = true;\n        super.replaceState(state, title, url);\n    }\n    onPopState(fn) {\n        // `Zone.current` will reference the zone that serves as an execution context\n        // to some specific application, especially when `onPopState` is called.\n        const zone = Zone.current;\n        // Wrap any event listener into zone that is specific to some application.\n        // The main issue is `back/forward` buttons of browsers, because they invoke\n        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n        // overrides `history.replaceState` Angular's zone cannot intercept this event.\n        // Only the root zone is able to intercept all events.\n        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n        fn = zone.wrap(fn, this.source);\n        const onPopStateListener = (event) => {\n            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n            // by `single-spa` starting from `5.4` version. We need this check because we want\n            // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n            const popStateEventWasDispatchedBySingleSpa = !!event\n                .singleSpa;\n            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n                this.skipNextPopState = false;\n            }\n            else {\n                fn(event);\n            }\n        };\n        return super.onPopState(onPopStateListener);\n    }\n    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: SingleSpaPlatformLocation, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }\n    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: SingleSpaPlatformLocation }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.4\", ngImport: i0, type: SingleSpaPlatformLocation, decorators: [{\n            type: Injectable\n        }] });\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\nfunction getSingleSpaExtraProviders() {\n    return [\n        {\n            provide: SingleSpaPlatformLocation,\n            deps: [[new Inject(DOCUMENT)]],\n        },\n        {\n            provide: PlatformLocation,\n            useExisting: SingleSpaPlatformLocation,\n        },\n    ];\n}\n\nconst defaultOptions = {\n    // Required options that will be set by the library consumer.\n    NgZone: null,\n    bootstrapFunction: null,\n    template: null,\n    // Optional options\n    Router: undefined,\n    domElementGetter: undefined,\n    updateFunction: () => Promise.resolve(),\n    bootstrappedNgModuleRefOrAppRef: null,\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nfunction singleSpaAngular(userOptions) {\n    if (NG_DEV_MODE && typeof userOptions !== 'object') {\n        throw Error('single-spa-angular requires a configuration object');\n    }\n    const options = {\n        ...defaultOptions,\n        ...userOptions,\n    };\n    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n        throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n    }\n    if (NG_DEV_MODE && typeof options.template !== 'string') {\n        throw Error('single-spa-angular must be passed options.template string');\n    }\n    if (NG_DEV_MODE && !options.NgZone) {\n        throw Error(`single-spa-angular must be passed the NgZone option`);\n    }\n    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n        // We call `console.warn` except of throwing `new Error()` since this will not\n        // be a breaking change.\n        console.warn(`single-spa-angular must be passed the NavigationStart option`);\n    }\n    return {\n        bootstrap: bootstrap.bind(null, options),\n        mount: mount.bind(null, options),\n        unmount: unmount.bind(null, options),\n        update: options.updateFunction,\n    };\n}\nasync function bootstrap(options) {\n    // Angular provides an opportunity to develop `zone-less` application, where developers\n    // have to trigger change detection manually.\n    // See https://angular.io/guide/zone#noopzone\n    if (options.NgZone === 'noop') {\n        return;\n    }\n    // Note that we have to make it a noop function because it's a static property and not\n    // an instance property. We're unable to configure it for multiple apps when dependencies\n    // are shared and reference the same `NgZone` class. We can't determine where this function\n    // is being executed or under which application, making it difficult to assert whether this\n    // app is running under its zone.\n    options.NgZone.assertInAngularZone = () => { };\n    options.NgZone.assertNotInAngularZone = () => { };\n    options.routingEventListener = () => {\n        options.bootstrappedNgZone.run(() => {\n            // See https://github.com/single-spa/single-spa-angular/issues/86\n            // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n            // unless we tell Zone that something happened\n        });\n    };\n}\nasync function mount(options, props) {\n    getContainerElementAndSetTemplate(options, props);\n    const bootstrapPromise = options.bootstrapFunction(props);\n    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n        throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n    }\n    const ngModuleRefOrAppRef = await bootstrapPromise;\n    if (NG_DEV_MODE) {\n        if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {\n            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n        }\n    }\n    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);\n    const ngZoneEnabled = options.NgZone !== 'noop';\n    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n        throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n    }\n    const bootstrappedOptions = options;\n    if (ngZoneEnabled) {\n        const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);\n        // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n        // function was not called.\n        if (singleSpaPlatformLocation !== null) {\n            skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);\n        }\n        bootstrappedOptions.bootstrappedNgZone = ngZone;\n        window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n    }\n    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;\n    return ngModuleRefOrAppRef;\n}\nfunction unmount(options) {\n    return Promise.resolve().then(() => {\n        if (options.routingEventListener) {\n            window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n        }\n        options.bootstrappedNgModuleRefOrAppRef.destroy();\n        options.bootstrappedNgModuleRefOrAppRef = null;\n    });\n}\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {\n    if (!options.NavigationStart) {\n        // As discussed we don't do anything right now if the developer doesn't provide\n        // `options.NavigationStart` since this might be a breaking change.\n        return;\n    }\n    const router = ngModuleRefOrAppRef.injector.get(options.Router);\n    const subscription = router.events.subscribe((event) => {\n        if (event instanceof options.NavigationStart) {\n            const currentNavigation = router.getCurrentNavigation();\n            // This listener will be set up for each Angular application\n            // that has routing capabilities.\n            // We set `skipLocationChange` for each non-imperative navigation,\n            // Angular router checks under the hood if it has to change\n            // the browser URL or not.\n            // If `skipLocationChange` is truthy then Angular router will not call\n            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n            if (currentNavigation.trigger !== 'imperative') {\n                currentNavigation.extras.skipLocationChange = true;\n                currentNavigation.extras.replaceUrl = false;\n            }\n        }\n    });\n    ngModuleRefOrAppRef.onDestroy(() => subscription.unsubscribe());\n}\n\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}